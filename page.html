<!doctype html>
<html lang='pt-br'>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mini FPS (Raycaster) — HTML/JS</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud">WASD: movimentar • Mouse: olhar • Clique para prender o cursor</div>
  <div id="hint">Pressione clique esquerdo para ativar o ponteiro e começar</div>
  <div id="cross">+</div>

<script>
// --- Mini raycaster FPS (single-file) ---
var canvas = document.getElementById('game');
var ctx = canvas.getContext('2d');
let W=canvas.width=innerWidth, H=canvas.height=innerHeight;
window.addEventListener('resize',()=>{W=canvas.width=innerWidth;H=canvas.height=innerHeight});

// Simple map: 0 empty, 1 wall, 2 target (enemy)
var MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,2,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,1,1,1,0,0,0,0,1],
  [1,0,0,0,1,0,1,0,0,0,0,1],
  [1,0,0,0,1,1,1,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1]
];
var MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],
  [1,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],
  [1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1],
  [1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],
  [1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
  [1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1],
  [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
  [1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

var MAP_W = MAP[0].length, MAP_H = MAP.length, TILE = 64;

// Player
var player = {x: TILE*2.5, y: TILE*2.5, ang: 0, speed: 0, side:0, height: 32};
let keys = {};

// Mouse look
let pointerLocked = false;
var sens = 0.0025;
canvas.addEventListener('click',()=>{ if(!pointerLocked) canvas.requestPointerLock(); shoot(); });
document.addEventListener('pointerlockchange',()=>{pointerLocked = document.pointerLockElement===canvas; document.getElementById('hint').style.display = pointerLocked? 'none':'block'});
document.addEventListener('mousemove',e=>{ if(pointerLocked){ player.ang += e.movementX * sens; }});

// Input
addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// Raycasting parameters
var FOV = Math.PI/3; // 60deg
var DEPTH = 800;

function gameLoop(ts){ update(); render(); requestAnimationFrame(gameLoop); }

function update(){
  // movement
  var forward = (keys['w']?1:0) - (keys['s']?1:0);
  var strafe = (keys['d']?1:0) - (keys['a']?1:0);
  var mv = 2.2;
  var dx = Math.cos(player.ang)*forward*mv + Math.cos(player.ang+Math.PI/2)*strafe*mv;
  var dy = Math.sin(player.ang)*forward*mv + Math.sin(player.ang+Math.PI/2)*strafe*mv;
  tryMove(dx,dy);
}

function tryMove(dx,dy){
  var nx = player.x + dx;
  var ny = player.y + dy;
  if(!isWallAt(nx, player.y)) player.x = nx;
  if(!isWallAt(player.x, ny)) player.y = ny;
}

function isWallAt(px,py){
  var mx = Math.floor(px / TILE);
  var my = Math.floor(py / TILE);
  if(mx<0||mx>=MAP_W||my<0||my>=MAP_H) return true;
  return MAP[my][mx] === 1;
}

// Shooting: cast a single ray and check if hit tile 2
let score = 0;
function shoot(){
  // simple cooldown could be added
  var rayAng = player.ang;
  for(let d=0; d<DEPTH; d+=4){
    var rx = player.x + Math.cos(rayAng)*d;
    var ry = player.y + Math.sin(rayAng)*d;
    var mx = Math.floor(rx/TILE), my = Math.floor(ry/TILE);
    if(mx<0||mx>=MAP_W||my<0||my>=MAP_H) break;
    var tile = MAP[my][mx];
    if(tile === 1){ break; }
    if(tile === 2){ // hit target
      MAP[my][mx] = 0; score++;
      hitFlash();
      break;
    }
  }
}

let flash = 0;
function hitFlash(){ flash = 10; }

function render(){
  // clear
  ctx.fillStyle = '#738'; // ceiling
  ctx.fillRect(0,0,W,H/2);
  ctx.fillStyle = '#444'; // floor
  ctx.fillRect(0,H/2,W,H/2);

  // raycast columns
  for(let x=0; x<W; x+=2){
    var camX = (2 * x / W - 1);
    var rayAng = player.ang + camX * (FOV/2);
    // step ray
    let dist = 0; let hit=false; let tile=0;
    while(!hit && dist < DEPTH){
      dist += 2;
      var rx = player.x + Math.cos(rayAng)*dist;
      var ry = player.y + Math.sin(rayAng)*dist;
      var mx = Math.floor(rx/TILE), my = Math.floor(ry/TILE);
      if(mx<0||mx>=MAP_W||my<0||my>=MAP_H){ hit=true; tile=1; break; }
      tile = MAP[my][mx];
      if(tile !== 0) hit = true;
    }
    // fish-eye correction
    var corrected = dist * Math.cos(rayAng - player.ang);
    var sliceH = Math.min(H, (TILE*H)/corrected);

    // shading
    let shade = 1 - Math.min(1, corrected/600);
    if(tile === 1){ ctx.fillStyle = `rgba(${Math.floor(180*shade)},${Math.floor(120*shade)},${Math.floor(80*shade)},1)`; }
    else if(tile === 2){ ctx.fillStyle = `rgba(${Math.floor(220*shade)},${Math.floor(30*shade)},${Math.floor(30*shade)},1)`; }
    else { ctx.fillStyle = '#000'; }

    var px = x; var py = (H/2) - sliceH/2;
    ctx.fillRect(px, py, 2, sliceH);
  }

  // simple mini-map
  var scale = 0.16; var mW = MAP_W * TILE * scale, mH = MAP_H*TILE*scale;
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(12,50,mW+8,mH+8);
  for(let my=0; my<MAP_H; my++) for(let mx=0; mx<MAP_W; mx++){
    var t=MAP[my][mx];
    if(t===1) ctx.fillStyle='#999';
    else if(t===2) ctx.fillStyle='#f55';
    else ctx.fillStyle='#222';
    ctx.fillRect(16+mx*TILE*scale,54+my*TILE*scale,TILE*scale-1,TILE*scale-1);
  }
  // player on minimap
  ctx.fillStyle='#0f0'; ctx.beginPath(); ctx.arc(16+player.x*scale,54+player.y*scale,4,0,Math.PI*2); ctx.fill();
  // view cone
  ctx.strokeStyle='rgba(0,255,0,0.2)'; ctx.beginPath(); ctx.moveTo(16+player.x*scale,54+player.y*scale);
  ctx.lineTo(16+(player.x+Math.cos(player.ang+FOV/2)*50)*scale,54+(player.y+Math.sin(player.ang+FOV/2)*50)*scale);
  ctx.moveTo(16+player.x*scale,54+player.y*scale);
  ctx.lineTo(16+(player.x+Math.cos(player.ang-FOV/2)*50)*scale,54+(player.y+Math.sin(player.ang-FOV/2)*50)*scale);
  ctx.stroke();

  // HUD
  ctx.fillStyle = 'white'; ctx.font='18px system-ui'; ctx.fillText('Score: '+score, 14, 42);

  // hit flash
  if(flash>0){ ctx.fillStyle='rgba(255,255,255,'+ (flash/12) +')'; ctx.fillRect(0,0,W,H); flash--; }
}

// start
requestAnimationFrame(gameLoop);

// small accessibility: click hint also focuses
canvas.style.cursor = 'crosshair';
</script>
</body>
</html>
